#!/usr/bin/python

from numpy import linalg as LA
import numpy as np


# -----------------------------------------------------------
# HELPER FUNCTIONS
# -----------------------------------------------------------

def normalize(v):
    norm = LA.norm(v)
    if norm == 0:
        return v
    return v / norm


def proj(u, w):
    return (np.vdot(u, w) / (LA.norm(w)) ** 2) * w


# -----------------------------------------------------------
# QR DECOMPOSITION ALGORITHM USING GRAM SCHMIDT METHOD.
# The algorithm performs a gram schmidt decomposition on
# the matrix and concurrently calculates R.
# -----------------------------------------------------------


def qr_decomp(A):
    # Get dimension of matrix.
    n = len(A)
    cp = A.copy()
    Q = np.zeros(shape=(n,n))
    R = np.zeros(shape=(n,n))

    for i in range(n):
        u = A[:, i]
        w = u
        for k in range(i):
            u -= proj(w, Q[:, k])
        Q[:, i] = normalize(u)
        for j in range(i + 1):
            R[j, i] = np.vdot(Q[:, j], cp[:, i])
    return Q, R


# -----------------------------------------------------------
# THE MAIN METHOD.
# -----------------------------------------------------------


def main():
    # Get input from the user.
    n = int(input("Please enter the size of the matrix you would like to generate.\n"))
    # Generate random matrix of correct dimensions
    #print('Generating a random symmetric matrix of size {} x {}\n'.format(n, n))
    b = np.random.random_integers(-100, 100, size=(n, n))
    # Make a symmetric matrix out of the generated matrix.
    A = (b + b.T) / 2
    # Run Gram Schmidt on the matrix.
    Q, R = qr_decomp(A)

    print('The obtained Q was:\n {}\n'.format(Q))
    print('The obtained R was:\n {}\n'.format(R))


if __name__ == "__main__":
    main()